import crypto from "node:crypto";
import path from "node:path";
import { readFile } from "node:fs/promises";
import { minify as htmlMinify } from "html-minifier-terser";

const htmlCache = new Map();
const inlineCssCache = new Map();

const htmlMinifyOptions = {
	collapseBooleanAttributes: true,
	collapseWhitespace: true,
	decodeEntities: true,
	html5: true,
	includeAutoGeneratedTags: false,
	keepClosingSlash: true,
	minifyCSS: true,
	minifyJS: true,
	processConditionalComments: true,
	processScripts: ["application/ld+json"],
	removeComments: true,
	removeEmptyAttributes: true,
	removeRedundantAttributes: true,
	removeScriptTypeAttributes: true,
	removeStyleLinkTypeAttributes: true,
	sortAttributes: true,
	sortClassName: true,
	useShortDoctype: true,
};

async function memoizedHtmlMinify(content) {
	const key = crypto.createHash("sha1").update(content).digest("hex");
	if (htmlCache.has(key)) {
		return htmlCache.get(key);
	}
	const minified = await htmlMinify(content, htmlMinifyOptions);
	htmlCache.set(key, minified);
	return minified;
}

export function registerHtmlMinifier(eleventyConfig, shouldMinify) {
	eleventyConfig.addTransform("html-minify", async function (content) {
		const outputPath = this.outputPath;
		if (
			!shouldMinify ||
			typeof outputPath !== "string" ||
			!outputPath.endsWith(".html")
		) {
			return content;
		}
		try {
			return await memoizedHtmlMinify(content);
		} catch (error) {
			console.warn(`[html-minify] Failed for ${outputPath}:`, error.message);
			return content;
		}
	});
}

export function registerInlineCssShortcode(eleventyConfig) {
	// Based on the Eleventy Quick Tip for inlining CSS to avoid extra requests.
	eleventyConfig.addAsyncShortcode("inlineCSS", async function inlineCSS(relativePath) {
		if (!relativePath) {
			throw new Error("inlineCSS shortcode requires a file path argument");
		}
		const normalized = relativePath.startsWith("/")
			? relativePath.slice(1)
			: relativePath;
		const filePath = path.resolve(process.cwd(), normalized);
		if (!inlineCssCache.has(filePath)) {
			const cssContent = await readFile(filePath, "utf-8");
			inlineCssCache.set(filePath, cssContent);
		}
		return inlineCssCache.get(filePath);
	});
}
